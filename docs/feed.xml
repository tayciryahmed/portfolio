<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" /><updated>2019-08-13T14:22:33-05:00</updated><id>/</id><title type="html">Taycir Yahmed</title><subtitle>Machine Learning, NLP</subtitle><entry><title type="html">mcQA - Multiple Choice Question Answering</title><link href="/mcQA" rel="alternate" type="text/html" title="mcQA - Multiple Choice Question Answering" /><published>2019-07-10T02:25:36-05:00</published><updated>2019-07-10T02:25:36-05:00</updated><id>/mcQA</id><content type="html" xml:base="/mcQA">&lt;p&gt;mcQA is a multiple choice question answering python library, using Language Models.&lt;/p&gt;

&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;/h2&gt;

&lt;h3 id=&quot;with-pip&quot;&gt;With pip&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pip install mcqa
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;from-source&quot;&gt;From source&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/mcqa-suite/mcqa.git
&lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;mcQA
pip install &lt;span class=&quot;nt&quot;&gt;-e&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;getting-started&quot;&gt;Getting started&lt;/h2&gt;

&lt;h3 id=&quot;data-preparation&quot;&gt;Data preparation&lt;/h3&gt;

&lt;p&gt;See example data preparation below:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;mcqa.data&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MCQAData&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;mcqa_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MCQAData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bert_model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bert-base-uncased&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;lower_case&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_seq_length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;train_dataset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mcqa_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'swagaf/data/train.csv'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_training&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;                  
&lt;span class=&quot;n&quot;&gt;test_dataset&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mcqa_data&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data_file&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'swagaf/data/test.csv'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_training&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;False&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;model-training&quot;&gt;Model training&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;mcqa.models&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;mdl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Model&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bert_model&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bert-base-uncased&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;cuda&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;span class=&quot;n&quot;&gt;mdl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_dataset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;train_batch_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_train_epochs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;prediction&quot;&gt;Prediction&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;preds&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mdl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;predict&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_dataset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;eval_batch_size&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;32&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;evaluation&quot;&gt;Evaluation&lt;/h3&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;sklearn.metrics&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;accuracy_score&lt;/span&gt;
&lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;mcqa.data&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_labels&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;accuracy_score&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;preds&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_labels&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;train_dataset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>taycir</name></author><summary type="html">mcQA is a multiple choice question answering python library, using Language Models.</summary></entry><entry><title type="html">Building Parallel Corpora Using Cross-Lingual BOW</title><link href="/Building-Parallel-Corpora-Using-Cross-Lingual-Bag-Of-Words" rel="alternate" type="text/html" title="Building Parallel Corpora Using Cross-Lingual BOW" /><published>2018-07-13T02:25:36-05:00</published><updated>2018-07-13T02:25:36-05:00</updated><id>/Building-Parallel-Corpora-Using-Cross-Lingual-Bag-Of-Words</id><content type="html" xml:base="/Building-Parallel-Corpora-Using-Cross-Lingual-Bag-Of-Words">&lt;p&gt;Training machine translation models requires a huge amount of parallel data.
Consequently, there has been many works suggesting different methods to build
bilingual corpora, leading to the construction of reliable training datasets for
machine translation systems.&lt;/p&gt;

&lt;p&gt;However, the problem is still prominent for the below use-cases:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Low-resource setup: Although for some language pairs, we have parallel datasets with a convenient size (e.g. around 50M sentences for French - English), this is not the case for all language pairs. Indeed, low resource languages do not have as much parallel data making it hard to
train reliable translation models to and from these languages.&lt;/li&gt;
  &lt;li&gt;Specialization setup: Furthermore, machine translation is sensitive to context. Thus, any available specialized data can have a strong influence on the model’s performance for a specific domain. For instance, using medical data when training the model enhances its performance on prescriptions’ translation. Note that there are various &lt;a href=&quot;https://arxiv.org/abs/1612.06140&quot;&gt;domain control&lt;/a&gt; strategies for machine translation, such as adding the domain tag as an additional feature or adding a special token to the sentence when training and translating; this is not, however, the core of this article.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Due to the aforementioned reasons, there is still room for designing and implementing solutions for building parallel corpora. In the following sections, I present a solution for matching multilingual documents in order to construct a parallel corpus.&lt;/p&gt;

&lt;h2 id=&quot;clbow-cross-lingual-bag-of-words&quot;&gt;CLBOW: Cross-Lingual Bag-Of-Words&lt;/h2&gt;

&lt;p&gt;When designing an algorithm to match cross-lingual documents, the first reflex is
to represent all available documents in numerical vectors. However, to compare
these documents, the vectorial representations should be language-independent
or cross-lingual, meaning that semantically similar documents should be close
in the multidimensional representation space.&lt;/p&gt;

&lt;p&gt;Although most recent research &lt;a href=&quot;https://arxiv.org/abs/1710.04087&quot;&gt;works&lt;/a&gt; focus on multilingual word embeddings as a numerical representation of text data, here we present a generalization of
Bag-Of-Words to a cross-lingual setup, where we represent all documents in the same space irrespectively of their language. Below is the explicit implementation of the algorithm:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/algo1.png&quot; alt=&quot;Implementation of CLBOW: Cross-Lingual Bag of Words&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Illustration of Cross-Lingual Bag-Of-Words (CLBOW):&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/cbow.png&quot; alt=&quot;Illustration of CLBOW: Cross-Lingual Bag-Of-Words&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Notes:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;In the above illustration, the decoding of only two languages is presented for simplicity purposes; nevertheless the suggested implementation is extended to many languages.&lt;/li&gt;
  &lt;li&gt;Furthermore, it can handle polysemy since at each decoding step t, not only one translation of the word wt is considered but its different translations.&lt;/li&gt;
  &lt;li&gt;This version of BOW can provide both binary and numerical representation of the documents. By numerical, I refer to the extension of TF-IDF (Term Frequency - Inverse Document Frequency) to a cross-lingual setup.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;application-to-parallel-corpora-construction&quot;&gt;Application to parallel corpora construction&lt;/h2&gt;
&lt;p&gt;Thanks to the previous algorithm, cross-lingual vectorial representations of the documents are calculated. Afterwards, a search for the closest document of a different language is performed using the minimization of the cosine distance and with regards to a threshold corresponding to the typical length ratio for the language pair. For instance, this threshold is equal to 1.5 for French-English bilingual corpora. A maximum accepted distance between a document and a candidate translated version is also considered, to discriminate documents having the same template (headers, footers, etc.). In my various experiments, this threshold is equal to 0.6.&lt;/p&gt;

&lt;p&gt;Using this method, classes of equivalence representing each the multilingual
versions of the same document are retrieved. For example, a class of equivalence
can be represented as the following:&lt;/p&gt;

&lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'fr'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Regle FR 29-01-2018.pdf'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
 &lt;span class=&quot;s&quot;&gt;'en'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'CS1548325.pdf'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; 
 &lt;span class=&quot;s&quot;&gt;'pt'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Regra 29-01-2018.pdf'&lt;/span&gt; 
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'fr'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'Doc 12052005.pdf'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;'en'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'To print.pdf'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
 &lt;span class=&quot;s&quot;&gt;'de'&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'pr12052005.pdf'&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Below is the detailed algorithm:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/algo2.png&quot; alt=&quot;Multilingual document matching&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To build bilingual corpora, I consider sequentially pairs of languages. Then on each pair of documents, I apply sentence alignment using the algorithm &lt;a href=&quot;http://mt-archive.info/AMTA-2010-Sennrich.pdf&quot;&gt;BLEUAlign&lt;/a&gt;. This will provide a bilingual parallel corpus for each data source relevant to a specific domain. These corpora are then used to train and specialize machine translation systems and using them enabled a good enhancement in &lt;a href=&quot;https://www.aclweb.org/anthology/P02-1040&quot;&gt;BLEU&lt;/a&gt; score. Generally, if ∆BLEU is the difference between the BLEU on a standard dataset and a specialized dataset of the general model, you should expect to gain around ∆BLEU on the specialized dataset using the augmented model.&lt;/p&gt;

&lt;h2 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;The here-presented pipeline enabled the construction of a specialized bilingual corpus, that I used to enhance the performance of translation models both on standard datasets and on specialized data (financial, medical, etc.). Other improvements are however to be tested in the near future, including neural encoding of multilingual documents.&lt;/p&gt;</content><author><name>taycir</name></author><summary type="html">Training machine translation models requires a huge amount of parallel data. Consequently, there has been many works suggesting different methods to build bilingual corpora, leading to the construction of reliable training datasets for machine translation systems.</summary></entry><entry><title type="html">Clause Augmentation for Better NMT</title><link href="/Clause-Augmentation-for-Better-NMT" rel="alternate" type="text/html" title="Clause Augmentation for Better NMT" /><published>2018-04-01T02:25:36-05:00</published><updated>2018-04-01T02:25:36-05:00</updated><id>/Clause-Augmentation-for-Better-NMT</id><content type="html" xml:base="/Clause-Augmentation-for-Better-NMT">&lt;p&gt;Most public parallel corpora are formed of long sentences. Consequently, neural translation models tend to generate a long output with n-grams repetition, even when they are exposed to a short sequence or a one-word example. This causes the repetition problem, explained by the fact that none of the neurons learns the representation of length, thus the model generates a long sequence by default. In other terms, the probability of appearance of the end-of-sentence token &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;eos&amp;gt;&lt;/code&gt; will not be high enough to stop the output generation when translating a short sequences.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Illustration of n-grams repetition on clauses translation:&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Source:&lt;/strong&gt; et il croit depuis lors a un taux de 5 %&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Translation:&lt;/strong&gt; since then and since then at 5 % at 5 %&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To solve this problem, a possible solution is augmenting the training parallel corpus with sequences of a smaller length, typically one-word examples (using bilingual dictionaries) and sub-sentences. To generate the sub-sentences, two important steps are considered:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;First, detect and segment clauses in long sentences.&lt;/li&gt;
  &lt;li&gt;Second, retrieve the clauses exact translation.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;clause-detection-and-segmentation&quot;&gt;Clause detection and segmentation&lt;/h2&gt;
&lt;p&gt;In neural machine translation, sentences with more that 50 tokens are usually dropped. According to many research &lt;a href=&quot;https://arxiv.org/abs/1409.0473&quot;&gt;papers&lt;/a&gt;, sentences with such length harm the performance. As a consequence, an approach is suggested to segment these sentences to clauses and thus use them while training instead of simply dropping them. The first task is detecting clauses in long sentences. To do so, linguistic rules, specific to each language that mark the beginning / end of a clause, are needed.
These rules are formulated within a Treebank.&lt;/p&gt;

&lt;p&gt;In linguistics, a treebank is a syntactic or semantic sentence structure annotator. The introduction of the first parsed corpora in the 90s, revolutionized computational linguistics, particularly after publishing &lt;a href=&quot;https://repository.upenn.edu/cgi/viewcontent.cgi?article=2068&amp;amp;context=cis_reports&quot;&gt;Penn Treebank&lt;/a&gt;, the first large-scale treebank. Indeed, annotated treebank data has been crucial in syntactic research to test linguistic theories of sentence structure. In addition, there are variants of treebanks, including phrase structure annotators and dependency structure annotators. Note that in these experiments, phrase structure annotators are used.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/anno.jpg&quot; alt=&quot;Variants of syntactic treebanks&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Since this experiment deals with French to English translation scenario, a French Treebank is needed. Due to license constraints and the need for phrase annotators, Paris 7 French Treebank was chosen. This Treebank was initiated in 1997, with the collaboration of IUF, CNRS and CNRTL. It consists of 1 million words of the newspaper Le Monde (1989-1995). The full list of the generated tags is accessible &lt;a href=&quot;http://www.llf.cnrs.fr/Gens/Abeille/French-Treebank-fr.php&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Clauses segmentation:&lt;/strong&gt; The first step is identifying the usually dropped sentences, those with more than 50 tokens (words). Afterwards, these sentences are annotated each with phrase tags using the French treebank. Below is an example for both French and English:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/tree.png&quot; alt=&quot;Clause detection and segmentation: French and English examples&quot; width=&quot;800&quot; /&gt;&lt;/p&gt;

&lt;p&gt;To select the clauses, specific tags are selected:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Selected tags for English:
    &lt;ul&gt;
      &lt;li&gt;S: simple declarative clause, i.e. one that is not introduced by a subordinating conjunction or a wh-word and that does not exhibit subject-verb inversion.&lt;/li&gt;
      &lt;li&gt;SBAR: Clause introduced by a subordinating conjunction.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Selected tags for French:
    &lt;ul&gt;
      &lt;li&gt;Ssub: subordinate clause (“completive”, indirect interrogative, circumstantial subordinate)&lt;/li&gt;
      &lt;li&gt;Sint: clause “conjuguee interne” (coordinated, direct speech, incise)&lt;/li&gt;
      &lt;li&gt;PP: prepositional phrase&lt;/li&gt;
      &lt;li&gt;Srel: relative proposition (starting with a relative pronoun)&lt;/li&gt;
      &lt;li&gt;COORD: coordinated phrase&lt;/li&gt;
      &lt;li&gt;VPinf: infinitive proposition (starting with a preposition)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Using these tags, the long sentences are segmented to the clauses that form them. So, whenever a new tag is encountered, when visiting the different nodes of the parsing tree, a new clause is generated. This segmentation step results in a corpus of short sequences in the source language. Now, the exact translations for these clauses have to be generated.&lt;/p&gt;

&lt;h2 id=&quot;synthetic-translation-of-the-extracted-clauses&quot;&gt;Synthetic translation of the extracted clauses&lt;/h2&gt;
&lt;p&gt;To translate the clauses, the original model can’t be used because it doesn’t handle short sequence translations and would generate n-gram repetition. However, in this section, a method allowing quality translation for sub-sentences is presented. Eventually, this proposed approach generates a bilingual corpus of short sequences / phrases.&lt;/p&gt;

&lt;p&gt;Below are the different steps applied to get the clauses’ translation:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Using the original model, translate the original long sentences, from which we previously extracted the clauses.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Extract the attention weights generated by the previous translations. The attention weights are denoted αij , representing the contribution of word i on the source side in the translation of word j in the target side. Note that i ranges from 1 to length of the source sentence, here denoted n; j ranges from 1 to length of the target sentence, here denoted m. See below an example of attention weights generated with translation:*&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/Image1.png&quot; alt=&quot;Attention weights generated with translation&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Here the source sentence is “Nous esperons qu’ il s’agit la d’une preuve de sa pertinence politique.” and the target prediction is “We hope that this is proof of its political relevance.”. Each cell αij , where 1 ≤ i ≤ n, 1 ≤ j ≤ m: n being the length of the source sentence and m being the length of the target sentence, represents the contribution of target word j in the translation of the source word i. Note that the lighter the cell, the more important the attention weight. &lt;br /&gt;&lt;br /&gt;&lt;/p&gt;

    &lt;p&gt;&lt;strong&gt;Important remark:&lt;/strong&gt; Here, the matrix is predominantly &lt;strong&gt;diagonal&lt;/strong&gt;: this indicates how much the French and English languages are aligned. An example of the attention matrix corresponding to non-aligned languages (Japanese to English) can be seen in the below figure.&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/assets/images/Image12.png&quot; alt=&quot;Attention matrix of Japanese to English translation&quot; width=&quot;400&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;Furthermore, some &lt;strong&gt;anti-diagonal&lt;/strong&gt; sections in the matrix can be observed, these are due to the difference in the order of adjective compounds between French and English, e.g. “pertinence politique” is translated to “political relevance”.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Apply the following algorithm to retrieve the clauses’ translation.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/algo.png&quot; alt=&quot;Clauses synthetic translation&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt; the thresholds 0.4 and 0.7 are selected after experiments on the alignment
between French and English languages. See below an illustration of synthetic translation of the first clause “Nous esperons”:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/Image2.png&quot; alt=&quot;Illustration of synthetic translation of the first clause 'Nous esperons'&quot; width=&quot;700&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Note that, in the graph on the right, the horizontal axis represents the position of words in the target sentence and the vertical axis represents the contribution of the corresponding target word in the translation of the clause (here: “Nous esperons”). The image below illustrates the &lt;em&gt;Information transfer through the source and target sentences:&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/transfer.png&quot; alt=&quot;Information transfer through the source and target sentences.&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;model-training-with-clauses&quot;&gt;Model training with clauses&lt;/h2&gt;
&lt;p&gt;Using the previously described processes, a bilingual corpus of clauses is constructed. However, in the following experiment, only 35,821 clauses are used, which makes around 3% of the available clauses. Furthermore, each set of clauses is concatenated to the corresponding corpus among the source (French) and the target (English). Afterwards, the two corpora are jointly randomized so that
the clauses are not located just in the end of the data set, but spread along the corpus. Then, the model is retrained during 13 epochs with the baseline setup: 2.5 million parallel sentences, 4 bidirectional LSTM attentional encoder-decoder architecture with 500 as embedding size, 500 as number of hidden units and 5 as beam size.&lt;/p&gt;

&lt;h2 id=&quot;results-and-discussion&quot;&gt;Results and discussion&lt;/h2&gt;
&lt;p&gt;Below, I present the scores obtained using this method on WMT 2015 test set and on a test set of clauses out-of-sample.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Experiment       &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;WMT BLEU      &lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Clauses BLEU&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;Baseline       &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;28.41      &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;49.73&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Augmented model      &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;28.85      &lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;58.31&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;strong&gt;Quantitative discussion:&lt;/strong&gt; Integrating the clauses improves the performance with 0.44 BLEU on WMT 2015 and 8.58 BLEU on a test set of clauses. Note that in this experiment, only 3% of the available clauses are used. &lt;br /&gt;&lt;br /&gt;
&lt;strong&gt;Qualitative discussion:&lt;/strong&gt; Integrating the clauses has an influence mostly on translating short sequences. The method was suggested to solve the problem of n-gram repetition and indeed it did. Below is an example illustrating how the augmented model translates short sequences:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Source:&lt;/strong&gt; et il croit depuis lors a un taux de 5 % &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Baseline translation:&lt;/strong&gt; since then and since then at 5 % at 5 % &lt;br /&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Augmented model:&lt;/strong&gt; and it has been growing since then at a rate of 5 % &lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>taycir</name></author><summary type="html">Most public parallel corpora are formed of long sentences. Consequently, neural translation models tend to generate a long output with n-grams repetition, even when they are exposed to a short sequence or a one-word example. This causes the repetition problem, explained by the fact that none of the neurons learns the representation of length, thus the model generates a long sequence by default. In other terms, the probability of appearance of the end-of-sentence token &amp;lt;eos&amp;gt; will not be high enough to stop the output generation when translating a short sequences.</summary></entry></feed>